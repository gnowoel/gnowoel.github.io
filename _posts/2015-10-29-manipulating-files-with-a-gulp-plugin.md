---
layout: post
title:  "Manipulating files with a Gulp plugin"
date:   2015-10-29 12:00:00
---

A Gulp plugin is just a Node.js module that happens to return a stream.
With [`through2`][], a thin wrapper of the core [stream API][], creating
a Gulp plugin can be as simple as this:

  [`through2`]: https://www.npmjs.com/package/through2
  [stream API]: https://nodejs.org/api/stream.html

```js
var through = require('through2');

module.exports = function() {
  return through.obj();
};
```

The [`through.obj()`][] method generates a [transform stream][] in
[object mode][].  Which means the stream would take an object from the
upstream, and after doing some processing, push an object off
downstream. The input and the output may or may not be the same object.

  [`through.obj()`]: https://github.com/rvagg/through2#api
  [transform stream]: https://nodejs.org/api/stream.html#stream_class_stream_transform
  [object mode]: https://nodejs.org/api/stream.html#stream_object_mode

The default stream generated by `through.obj()` is a simple passthrough
stream. It doesn't do anything with the received object, just passing it
down as-is. We can specify what to do by providing a callback function,
as shown below:

```js
var through = require('through2');

module.exports = function() {
  return through.obj(function(file, _, next) {
    // do something with the file object here
    next(null, file);
  )};
};
```

For a Gulp plugin, the object received from the upstream is usually a
[Vinyl][] file. A Vinyl object is a JavaScript representation of a file.
It defines methods and properties for manipulating the file it
represents. For instance, we could use [`file.contents`][] for changing
the contents of a file.

  [Vinyl]: https://www.npmjs.com/package/vinyl
  [`file.contents`]: https://github.com/gulpjs/vinyl#contents

The Gulp documentation gives an [example][] of adding text to the
beginning of all files. This would illustrate how to manipulate a file
via a Vinyl object.

  [example]: https://github.com/gulpjs/gulp/blob/a2715207edb284b44921537e4d5901e2be1a482c/docs/writing-a-plugin/guidelines.md#what-does-a-good-plugin-look-like

The functionality can be accomplished by concatenating the user-provided
text and the original contents of the file. By default, `file.contents`
is a [Buffer](https://nodejs.org/api/buffer.html) object. To concatenate
buffers, we could use the [`Buffer.concat()`][] method:

  [`Buffer.concat()`]: https://nodejs.org/api/buffer.html#buffer_class_method_buffer_concat_list_totallength

```js
var prefixText = new Buffer('YOUR TEXT');

file.contents = Buffer.concat([prefixText, file.contents]);
```

We save the result back to the `file.contents` property, so the contents
of the underlying file will be changed accordingly.

Putting this idea to the skeleton code above, we now have a Gulp plugin
that does some real work:

```js
var through = require('through2');

function gulpPrefixer(prefixText) {
  prefixText = new Buffer(prefixText);

  return through.obj(function(file, _, next) {
    file.contents = Buffer.concat([prefixText, file.contents]);
  });

  cb(null, file);
}

module.exports = gulpPrefixer;
```

Save the module to file, and we can use it as would any other Gulp
plugin:

```js
var prefixer = require('./gulp-prefixer');

gulp.task('default', function() {
  return gulp.src('src/**/*')
    .pipe(prefixer('YOUR TEXT'))
    .pipe(gulp.dest('dist'));
});
```

The `file.contents` was populated with the invocation of the `gulp.src`
method. If we set the `buffer` flag to `false`, the value of
`file.contents` would be a stream:

```js
var prefixer = require('./gulp-prefixer');

gulp.task('default', function() {
  return gulp.src('src/**/*', { buffer: false })
    .pipe(prefixer('YOUR TEXT'))
    .pipe(gulp.dest('dist'));
});
```

For this case, concatenating the user text and the original contents
means piping them to a stream sequentially. We could use `through2` to
create a transform stream as the target:

```js
var stream = through();
var prefixText = new Buffer('YOUR TEXT');

stream.write(prefixText);
file.contents = file.contents.pipe(stream);
```

Here we use the [`through`][] method rather than `through.obj`, because
we're dealing with the internal contents of a stream, which are buffers,
not objects.

  [`through`]: https://github.com/rvagg/through2#api

The [`stream.write`][] method is used for manually pushing a buffer. And the
[`stream.pipe`][] method is used for chaining together two streams.

  [`stream.write`]: https://nodejs.org/api/stream.html#stream_writable_write_chunk_encoding_callback
  [`stream.pipe`]: https://nodejs.org/api/stream.html#stream_readable_pipe_destination_options

With this in place, we can write the plugin as follows:

```js
var through = require('through2');

function prefixStream(prefixText) {
  var stream = through();
  stream.write(prefixText);
  return stream;
}

function gulpPrefixer(prefixText) {
  prefixText = new Buffer(prefixText);

  return through.obj(function(file, _, next) {
    file.contents = file.contents.pipe(prefixStream(prefixText));
  });

  cb(null, file);
}

module.exports = gulpPrefixer;
```

In these examples, we handle buffer and stream contents separately. But
a real Gulp plugin should handle both cases at the same time. The
[`file.isBuffer`] and [`file.isStream`] method would be handy here.
There're other requirements such as error handling should also be
considered. Refer to the [official documentation][] for a compele code
listing.

  [`file.isBuffer`]: https://github.com/gulpjs/vinyl#isbuffer
  [`file.isStream`]: https://github.com/gulpjs/vinyl#isstream
  [official documentation]: https://github.com/gulpjs/gulp/blob/a2715207edb284b44921537e4d5901e2be1a482c/docs/writing-a-plugin/guidelines.md#what-does-a-good-plugin-look-like
